## 1. 기억장치

- 접근 속도가 빠른고, 기억비용이 높은 순
1. 1차 기억장치 : 레지스터, 메모리 등
2. 2차 기억장치 : HDD, CD, DVD, 플래시 메모리 등
3. 3차 기억장치 : 테이프 등.
- 기억비용이란?
- 데이터를 저장하는데 소모되는 비용.
- 트레이드오프 발생! 
- why? : 많은 데이터를 영속적으로 저장하려 하면 속도를 읽고, 속도를 얻고자 하면 많은 데이터를 영속적으로 저장하기 힘들기 때문.

## 2. DBMS와 기억장치의 관계

### 1) 하드디스크(HDD)

- 대부분 데이터를 저장하는 매체로 HDD를 사용.
- 2차 기억장치로 분류되고, 대부분의 시스템에 범용적으로 사용됨.

### 2) 메모리

- 메모리는 디스크에 비해 기억 비용이 굉장히 비쌈.
- 하드웨어 1대에 탑재할 수 있는 양이 크지 않음.
- 가장 빠른 1차 기억장치.

### 3) 버퍼를 활용한 속도 향상

- DBMS가 일부라도 데이터를 메모리에 올리는 이유는 **성능 향상** 때문.
- 자주 접근하는 데이터를 메모리 위에 올려둔다면, 같은 SQL 구문을 실행한다고 해도 디스크에서 데이터를 가져올 필요 없이 곧바로 메모리에서 읽어 빠르게 데이터를 검색할 수 있음.
- 성능 향상을 목적으로 데이터를 저장하는 메모리를 **버퍼(buffer) 또는 캐시(cache)**라고 부름.

## 3. 메모리 위에 있는 두 개의 버퍼

### 1) 데이터 캐시

- 데이터 캐시는 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역.
- 실행한 select 구문에서 선택하고 싶은 데이터가 운 좋게 모두 이러한 데이터 캐시에 있다면, 디스크와 같은 저속 저장소에 접근하지 않고 처리가 수행. 따라서 굉장히 빠르게 응답.

### 2) 로그 버퍼

- 로그 버퍼는 갱신 처리(insert, delete, update, merge)와 관련이 있음.
- DBMS는 갱신과 관련된 sql구문을 사용자로부터 받으면, 곧바로 저장소에 있는 데이터를 변경하지 않음.
- 일단 로그 버퍼 위에 변경 정보를 보내고 이후 디스크에 변경을 수행.
- 데이터베이스의 갱신 처리는 sql 구문의 실행 시점과 저장소에 개인하는 시점에 차이가 있는 비동기 처리.
- 이러한 시점의 차이를 두는 이유는 처리 속도의 성능을 높이기 위해서인데, 갱신 처리를 할 때 상당한 시간이 소모되므로 한 번 메모리에 갱신 정보를 받은 시점에서는 사용자에게 sql 구문이 끝났다라고 통지하고, 내부적으로 관련된 처리를 계속 수행,

## 4. 메모리의 성질이 초래하는 트레이드오프

### 1) 휘발성

- 하드웨어의 전원을 꺼버리면 메모리 위에 올라가 있는 모든 데이터가 사라지는데 이런 성질을 **휘발성**이라 함.
- 메모리가 영속성이 없는 이상 기능적으로 디스크를 완전히 대체하는 것은 불가능.

### 2) 휘발성의 문제점

- 장애가 발생했을 때 메모리에 있던 데이터가 모두 사라져버려 데이터 부정합을 발생시킴.
- 로그 버퍼 위에 존재하는 데이터가 디스크 위의 로그 파일에 반영되기 전에 장애가 발생해서 사라져버리면 복구조차 불가능.

### 3) 트레이드오프 발생

- DBMS는 커밋 시점에 반드시 갱신 정보를 로그 파일에 씀으로써, 장애가 발생해도 정합성을 유지할 수 있게 할 수 있다. 그렇지만 커밋 때는 반드시 디스크에 동기 접근이 일어나므로 여기서 지연이 발생한 가능성이 있음.
- 디스크에 동기 처리를 한다면 데이터 정합성은 높아지지만 성능이 낮아지는 트레이드오프가 발생함.

## 5. 시스템 특성에 따른 트레이드오프

- 데이터 캐시와 로그 버퍼를 비교해보면 oracle, mysql, postgreSQL의 DBMS에 공통으로 데이터 캐시에 비해 로그 버퍼의 초기값이 굉장히 작다는 것을 알 수 있음.
- 데이터베이스가 2개의 버퍼에 대해 이렇게 극단적으로 비대칭적인 크기를 할당한 데는 데이터베이스가 기본적으로 **검색을 메인으로 처리**한다고 가정하기 때문.
- 검색 처리를 할 때는 검색 대상 레코드가 수백 만에서 수천만 건에 달하는 경우도 많지만, 갱신 처리를 할 때는 갱신 대상이 많아봤자 트랜잭션 마다 한건에서 수만 건 정도박에 되지 않음.
- 따라서, 갱신 처리에 값비싼 메모리를 많이 사용하는 것보다는, 자주 검색하는 데이터를 캐시에 올려놓는 것이 좋다고 생각하는 것.
- 만드는 시스템이 검색에 비해 갱신이 많다면, 로그 버퍼의 크기를 늘려줄 수 있음.
- 위처럼, 검색과 갱신 중에서 어떤 것이 더 우선되어야 하는가 라는 트레이드오프가 발생함.

## 6. 워킹 메모리

- 워킹메모리는 정렬 또는 해시 관련 처리에 사용되는 작업용 메모리 영역.
- 정렬은 order by구, 집합 연산, 윈도우 함수 등의 기능을 사용할 때 실행.
- 해시는 주로 테이블 등의 결합에서 해시 결합이 사용될 때 실행.
- 이 작업용 메모리 영역은 sql에서 정렬 또는 해시가 필요한 때 사용되고, 종료되면 해제되는 임시 영역으로, 일반적으로 데이터 캐시와 로그 버퍼와는 다른 영역으로 관리되는 경우가 많음.

### 1) 중요한이유

- 만약 이 영역이 다루려는 데이터양보다 작아 부족해지는 경우가 생기면 대부분의 DBMS가 저장소를 사용하기 때문.
- 많은 DBMS는 워킹 메모리가 부족할 때 사용하는 임시적인 영역을 가지고 있고, 이 일시 영역들은 저장소 위에 있으므로 당연히 접근 속도가 느림.

### 2) 워킹 메모리가 부족한 경우

- 메모리에서 작동하고 있을 때는 빠르게 움직이다가, 메모리가 부족해지는 순간 갑자기 느려지는 순간적인 변화가 일어남.
