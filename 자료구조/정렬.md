# 정렬

## 1. 삽입정렬(Insertion Sort)
 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬되는 알고리즘. <br>
매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 값을 넣는다.<br>
삽입 정렬은 두 번째 요소부터 시작하여 그 앞의 요소들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬한다. <br>

### 1) 예제
![image](https://user-images.githubusercontent.com/74750848/120271595-93a0fd00-c2e6-11eb-8ec4-283f1e997a14.png)

### 2) 장점
- 안정적인 정렬 방법
- 알고리즘 구현이 간단.

### 3) 단점
- 많은 레코드의 이동이 필요.
- 이동할 레코드 수가 ㅁ낳고 레코드 크기가 클 경우 적합하지 않음.

### 4) 시간복잡도
- 최선 : O(n)
- 최악 : O(n^2)

## 2. 선택정렬(Selection Sort)
 제자리 정렬 알고리즘의 하나로, 해당 순서에 원소를 넣을 위치는 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘. <br>
선택 정렬은 첫 번째 요소를 두 번째 요소부터 마지막 요소까지 차례대로 비교하여 가장 작은 값을 찾아 첫번째에 놓고, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와
차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행. <br>

### 1) 예제
![image](https://user-images.githubusercontent.com/74750848/120272500-2db57500-c2e8-11eb-80cd-bf6378a32af7.png)

### 2) 장점
- 자료 이동 횟수가 미리 결정.

### 3) 단점
- 안정성 만족 X.
- 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있음.

### 4) 시간복잡도
- 최선, 최악 : O(n^2)

